.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Perl::Tags 3"
.TH Perl::Tags 3 "2013-09-04" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Perl::Tags \- Generate (possibly exuberant) Ctags style tags for Perl sourcecode
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 6
\&        use Perl::Tags;
\&        my $naive_tagger = Perl::Tags::Naive\->new( max_level=>2 );
\&        $naive_tagger\->process(
\&            files => [\*(AqFoo.pm\*(Aq, \*(Aqbar.pl\*(Aq],
\&            refresh=>1 
\&        );
.Ve
.PP
Recursively follows \f(CW\*(C`use\*(C'\fR and \f(CW\*(C`require\*(C'\fR statements, up to a maximum
of \f(CW\*(C`max_level\*(C'\fR.
.PP
The implemented tagger, \f(CW\*(C`Perl::Tags::Naive\*(C'\fR is a more-or-less straight
ripoff, slightly updated, of the original pltags code, and is rather
naive.  It should be possible to subclass using something like \f(CW\*(C`PPI\*(C'\fR
or \f(CW\*(C`Text::Balanced\*(C'\fR, though be aware that this is alpha software and
the internals are subject to change (so get in touch to let me know
what you want to do and I'll try to help).
.SH "FEATURES"
.IX Header "FEATURES"
.Vb 2
\&    * Recursive, incremental tagging.
\&    * parses \`use_ok\`/\`require_ok\` line from Test::More
.Ve
.SH "USING with VIM"
.IX Header "USING with VIM"
\&\f(CW\*(C`Perl::Tags\*(C'\fR is designed to be used with vim.  My \f(CW\*(C`~/.vim/ftplugin/perl.vim\*(C'\fR
contains the following:
.PP
.Vb 1
\&    setlocal iskeyword+=:  " make tags with :: in them useful
\&
\&    if ! exists("s:defined_functions")
\&    function s:init_tags()
\&        perl <<EOF
\&            use Perl::Tags;
\&            $naive_tagger = Perl::Tags::Naive\->new( max_level=>2 );
\&                # only go one level down by default
\&    EOF
\&    endfunction
\&
\&    " let vim do the tempfile cleanup and protection
\&    let s:tagsfile = tempname()
\&
\&    function s:do_tags(filename)
\&        perl <<EOF
\&            my $filename = VIM::Eval(\*(Aqa:filename\*(Aq);
\&
\&            $naive_tagger\->process(files => $filename, refresh=>1 );
\&
\&            my $tagsfile=VIM::Eval(\*(Aqs:tagsfile\*(Aq);
\&            VIM::SetOption("tags+=$tagsfile");
\&
\&            # of course, it may not even output, for example, if there\*(Aqs nothing new to process
\&            $naive_tagger\->output( outfile => $tagsfile );
\&    EOF
\&    endfunction
\&
\&    call s:init_tags() " only the first time
\&
\&    let s:defined_functions = 1
\&    endif
\&
\&    call s:do_tags(expand(\*(Aq%\*(Aq))
\&
\&    augroup perltags
\&    au!
\&    autocmd BufRead,BufWritePost *.pm,*.pl call s:do_tags(expand(\*(Aq%\*(Aq))
\&    augroup END
.Ve
.PP
Note the following:
.IP "\(bu" 4
You will need to have a vim with perl compiled in it.  Debuntu packages this as \f(CW\*(C`vim\-perl\*(C'\fR.
Alternatively you can compile from source (you'll need Perl + the development headers \f(CW\*(C`libperl\-dev\*(C'\fR).
.IP "\(bu" 4
The \f(CW\*(C`EOF\*(C'\fR in the examples has to be at the beginning of the line (the verbatim text above has leading whitespace)
.SH "METHODS"
.IX Header "METHODS"
.ie n .SS """new"""
.el .SS "\f(CWnew\fP"
.IX Subsection "new"
Perl::Tags is an abstract baseclass.  Perl::Tags::Naive is provided
and can be instantiated with \f(CW\*(C`new\*(C'\fR.
.PP
.Vb 1
\&    $naive_tagger = Perl::Tags::Naive\->new( max_level=>2 );
.Ve
.PP
Accepts the following parameters
.PP
.Vb 3
\&    max_level:    levels of "use" statements to descend into, default 2
\&    do_variables: tag variables?  default 1 (true)
\&    exts:         use the Exuberant extensions
.Ve
.ie n .SS """to_string"""
.el .SS "\f(CWto_string\fP"
.IX Subsection "to_string"
A Perl::Tags object will stringify to a textual representation of a ctags file.
.PP
.Vb 1
\&    print $tagger;
.Ve
.ie n .SS """clean_file"""
.el .SS "\f(CWclean_file\fP"
.IX Subsection "clean_file"
Delete all tags, but without touching the \*(L"order\*(R" seen, that way, if the tags are recreated, they will remain near the top
of the \*(L"interestingness\*(R" tree
.ie n .SS """output"""
.el .SS "\f(CWoutput\fP"
.IX Subsection "output"
Save the file to disk if it has changed.  (The private \f(CW\*(C`{is_dirty}\*(C'\fR attribute
is used, as the tags object may be made up incrementally and recursively within
your \s-1IDE.\s0
.ie n .SS """process"""
.el .SS "\f(CWprocess\fP"
.IX Subsection "process"
Scan one or more Perl file for tags
.PP
.Vb 7
\&    $tagger\->process( 
\&        files => [ \*(AqModule.pm\*(Aq,  \*(Aqscript.pl\*(Aq ] 
\&    );
\&    $tagger\->process(
\&        files   => \*(Aqscript.pl\*(Aq,
\&        refresh => 1,
\&    );
.Ve
.ie n .SS """queue"", ""popqueue"""
.el .SS "\f(CWqueue\fP, \f(CWpopqueue\fP"
.IX Subsection "queue, popqueue"
Internal methods managing the processing
.ie n .SS """process_item"", ""process_file"""
.el .SS "\f(CWprocess_item\fP, \f(CWprocess_file\fP"
.IX Subsection "process_item, process_file"
Do the heavy lifting for \f(CW\*(C`process\*(C'\fR above.
.ie n .SS """register"""
.el .SS "\f(CWregister\fP"
.IX Subsection "register"
The parsing is done by a number of lightweight objects (parsers) which look
for subroutine references, variables, module inclusion etc.  When they are
successful, they call the \f(CW\*(C`register\*(C'\fR method in the main tags object.
.ie n .SS """get_parsers"""
.el .SS "\f(CWget_parsers\fP"
.IX Subsection "get_parsers"
Return the parses for this object.  Abstract, see Perl::Tags::Naive below.
.ie n .SH """Perl::Tags::Naive"""
.el .SH "\f(CWPerl::Tags::Naive\fP"
.IX Header "Perl::Tags::Naive"
A naive implementation.  That is to say, it's based on the classic \f(CW\*(C`pltags.pl\*(C'\fR script
distributed with Perl, which is by and large a better bet than the results produced by
\&\f(CW\*(C`ctags\*(C'\fR.  But a \*(L"better\*(R" approach may be to integrate this with \s-1PPI.\s0
.SS "Subclassing"
.IX Subsection "Subclassing"
See TodoTagger in the \f(CW\*(C`t/\*(C'\fR directory of the distribution for a fully
working example (tested in <t/02_subclass.t>).  You may want to reuse parsers
in the ::Naive package, or use all of the existing parsers and add your own.
.PP
.Vb 3
\&    package My::Tagger;
\&    use Perl::Tags;
\&    our @ISA = qw( Perl::Tags::Naive );
\&
\&    sub get_parsers {
\&        my $self = shift;
\&        return (
\&            $self\->can(\*(Aqtodo_line\*(Aq),     # a new parser
\&            $self\->SUPER::get_parsers(), # all ::Naive\*(Aqs parsers
\&            # or maybe...
\&            $self\->can(\*(Aqvariable\*(Aq),      # one of ::Naive\*(Aqs parsers
\&        );
\&    }
\&
\&    sub todo_line { 
\&        # your new parser code here!
\&    }
\&    sub package_line {
\&        # override one of ::Naive\*(Aqs parsers
\&    }
.Ve
.PP
Because ::Naive uses \f(CW\*(C`can(\*(Aqparser\*(Aq)\*(C'\fR instead of \f(CW\*(C`\e&parser\*(C'\fR, you
can just override a particular parser by redefining in the subclass.
.ie n .SS """get_parsers"""
.el .SS "\f(CWget_parsers\fP"
.IX Subsection "get_parsers"
The following parsers are defined by this module.
.ie n .IP """trim""" 4
.el .IP "\f(CWtrim\fR" 4
.IX Item "trim"
A filter rather than a parser, removes whitespace and comments.
.ie n .IP """variable""" 4
.el .IP "\f(CWvariable\fR" 4
.IX Item "variable"
Tags definitions of \f(CW\*(C`my\*(C'\fR, \f(CW\*(C`our\*(C'\fR, and \f(CW\*(C`local\*(C'\fR variables.
.Sp
Returns a Perl::Tags::Tag::Var if found
.ie n .IP """package_line""" 4
.el .IP "\f(CWpackage_line\fR" 4
.IX Item "package_line"
Parse a package declaration, returning a Perl::Tags::Tag::Package if found.
.ie n .IP """sub_line""" 4
.el .IP "\f(CWsub_line\fR" 4
.IX Item "sub_line"
Parse the declaration of a subroutine, returning a Perl::Tags::Tag::Sub if found.
.ie n .IP """use_constant""" 4
.el .IP "\f(CWuse_constant\fR" 4
.IX Item "use_constant"
Parse a use constant directive
.ie n .IP """use_line""" 4
.el .IP "\f(CWuse_line\fR" 4
.IX Item "use_line"
Parse a use, require, and also a use_ok line (from Test::More).
Uses a dummy tag (Perl::Tags::Tag::Recurse to do so).
.ie n .IP """label_line""" 4
.el .IP "\f(CWlabel_line\fR" 4
.IX Item "label_line"
Parse label declaration
.ie n .SH """Perl::Tags::Tag"""
.el .SH "\f(CWPerl::Tags::Tag\fP"
.IX Header "Perl::Tags::Tag"
A superclass for tags
.ie n .SS """new"""
.el .SS "\f(CWnew\fP"
.IX Subsection "new"
Returns a new tag object
.ie n .SS """type"", ""modify_options"""
.el .SS "\f(CWtype\fP, \f(CWmodify_options\fP"
.IX Subsection "type, modify_options"
Abstract methods
.ie n .SS """to_string"""
.el .SS "\f(CWto_string\fP"
.IX Subsection "to_string"
A tag stringifies to an appropriate line in a ctags file.
.ie n .SS """on_register"""
.el .SS "\f(CWon_register\fP"
.IX Subsection "on_register"
Allows tag to meddle with process when registered with the main tagger object.
Return false if want to prevent registration (true normally).`
.ie n .SH """Perl::Tags::Tag::Package"""
.el .SH "\f(CWPerl::Tags::Tag::Package\fP"
.IX Header "Perl::Tags::Tag::Package"
.ie n .SS """type"": p"
.el .SS "\f(CWtype\fP: p"
.IX Subsection "type: p"
.ie n .SS """modify_options"""
.el .SS "\f(CWmodify_options\fP"
.IX Subsection "modify_options"
Sets static=0
.ie n .SS """on_register"""
.el .SS "\f(CWon_register\fP"
.IX Subsection "on_register"
Sets the package name
.ie n .SH """Perl::Tags::Tag::Var"""
.el .SH "\f(CWPerl::Tags::Tag::Var\fP"
.IX Header "Perl::Tags::Tag::Var"
.ie n .SS """type"": v"
.el .SS "\f(CWtype\fP: v"
.IX Subsection "type: v"
.ie n .SS """on_register"""
.el .SS "\f(CWon_register\fP"
.IX Subsection "on_register"
.Vb 6
\&        Make a tag for this variable unless we\*(Aqre told not to.  We
\&        assume that a variable is always static, unless it appears
\&        in a package before any sub.  (Not necessarily true, but
\&        it\*(Aqs ok for most purposes and Vim works fine even if it is
\&        incorrect)
\&            \- pltags.pl comments
.Ve
.ie n .SH """Perl::Tags::Tag::Sub"""
.el .SH "\f(CWPerl::Tags::Tag::Sub\fP"
.IX Header "Perl::Tags::Tag::Sub"
.ie n .SS """type"": s"
.el .SS "\f(CWtype\fP: s"
.IX Subsection "type: s"
.ie n .SS """on_register"""
.el .SS "\f(CWon_register\fP"
.IX Subsection "on_register"
.Vb 5
\&        Make a tag for this sub unless we\*(Aqre told not to.  We assume
\&        that a sub is static, unless it appears in a package.  (Not
\&        necessarily true, but it\*(Aqs ok for most purposes and Vim works
\&        fine even if it is incorrect)
\&            \- pltags comments
.Ve
.ie n .SH """Perl::Tags::Tag::Constant"""
.el .SH "\f(CWPerl::Tags::Tag::Constant\fP"
.IX Header "Perl::Tags::Tag::Constant"
.ie n .SS """type"": c"
.el .SS "\f(CWtype\fP: c"
.IX Subsection "type: c"
.ie n .SH """Perl::Tags::Tag::Label"""
.el .SH "\f(CWPerl::Tags::Tag::Label\fP"
.IX Header "Perl::Tags::Tag::Label"
.ie n .SS """type"": l"
.el .SS "\f(CWtype\fP: l"
.IX Subsection "type: l"
.ie n .SH """Perl::Tags::Tag::Recurse"""
.el .SH "\f(CWPerl::Tags::Tag::Recurse\fP"
.IX Header "Perl::Tags::Tag::Recurse"
.ie n .SS """type"": dummy"
.el .SS "\f(CWtype\fP: dummy"
.IX Subsection "type: dummy"
.ie n .SS """on_register"""
.el .SS "\f(CWon_register\fP"
.IX Subsection "on_register"
Recurse adding this new module to the queue.
.SH "CONTRIBUTIONS"
.IX Header "CONTRIBUTIONS"
Contributions are always welcome.  The repo is in git:
.PP
.Vb 1
\&    http://github.com/osfameron/perl\-tags
.Ve
.PP
Please fork and make pull request.  Maint bits available on request.
.IP "wolverian" 4
.IX Item "wolverian"
::PPI subclass
.IP "Ian Tegebo" 4
.IX Item "Ian Tegebo"
patch to use File::Temp
.IP "\s-1DMITRI\s0" 4
.IX Item "DMITRI"
patch to parse constant and label declarations
.IP "drbean" 4
.IX Item "drbean"
::Naive::Spiffy and ::Naive::Lib subclasses
.IP "Alias" 4
.IX Item "Alias"
prodding me to make repo public
.IP "nothingmuch" 4
.IX Item "nothingmuch"
::PPI fixes
.IP "tsee" 4
.IX Item "tsee"
Command line interface, applying patches
.SH "AUTHOR and LICENSE"
.IX Header "AUTHOR and LICENSE"
.Vb 2
\&    osfameron (2006\-2009) \- osfameron@cpan.org
\&                            and contributors, as above
.Ve
.PP
For support, try emailing me or grabbing me on irc #london.pm on irc.perl.org
.PP
This was originally ripped off pltags.pl, as distributed with vim
and available from <http://www.mscha.com/mscha.html?pltags#tools>
Version 2.3, 28 February 2002
Written by Michael Schaap <pltags@mscha.com>.
.PP
This is licensed under the same terms as Perl itself.  (Or as Vim if you prefer).
